# This workflow runs a simple platform build using Visual Studio.
#
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: BSD-2-Clause-Patent


name: "Platform CI"

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main

jobs:
  ci:
    name: Platform CI
    runs-on: windows-2022
    permissions:
      actions: read
      contents: read
      security-events: write

    strategy:
      fail-fast: false
      matrix:
        build_file: ${{ fromJson('["Platforms/QemuQ35Pkg/PlatformBuild.py"]') }}
        include:
          - tool_chain_tag: VS2022

    steps:
    - name: Checkout repository
      uses: actions/checkout@v4

    - name: Install Python
      uses: actions/setup-python@v5
      with:
        python-version: '3.12'
        cache: 'pip'
        cache-dependency-path: 'pip-requirements.txt'

    - name: Use Git Long Paths on Windows
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        git config --system core.longpaths true

    - name: Install/Upgrade pip Modules
      run: pip install -r pip-requirements.txt --upgrade requests

    - name: Get Cargo Tool Details
      id: get_cargo_tool_details
      shell: python
      env:
        AUTH_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      run: |
        import os
        import requests
        import sys
        import time

        def get_response_with_retries(url, headers, retries=5, wait_time=10):
          for attempt in range(retries):
            response = requests.get(url, headers=headers)
            if response.status_code == 200:
              return response
            print(f"::warning title=GitHub API Access Error!::Attempt {attempt + 1} failed ({response.status_code}). Retrying in {wait_time} seconds...")
            time.sleep(wait_time)
          return response

        GITHUB_REPO = "sagiegurari/cargo-make"
        api_url = f"https://api.github.com/repos/{GITHUB_REPO}/releases/tags/0.37.24"
        headers = {
          "Authorization": f"Bearer {os.environ['AUTH_TOKEN']}",
          "Accept": "application/vnd.github.v3+json"
        }

        response = get_response_with_retries(api_url, headers)
        if response.status_code == 200:
          build_release_id = response.json()["id"]
        else:
          print(f"::error title=GitHub Release Error!::Failed to get cargo-make release ID! ({response.status_code})")
          sys.exit(1)

        api_url = f"https://api.github.com/repos/{GITHUB_REPO}/releases/{build_release_id}"

        response = get_response_with_retries(api_url, headers)
        if response.status_code == 200:
          latest_cargo_make_version = response.json()["tag_name"]
        else:
          print(f"::error title=GitHub Release Error!::Failed to get cargo-make! ({response.status_code})")
          sys.exit(1)

        cache_key = f'cargo-make-{latest_cargo_make_version}'

        with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
          print(f'cargo_bin_path={os.path.join(os.environ["USERPROFILE"], ".cargo", "bin")}', file=fh)
          print(f'cargo_make_cache_key={cache_key}', file=fh)
          print(f'cargo_make_version={latest_cargo_make_version}', file=fh)

    # Temporarily disable caching cargo-make as it stopped working in some repos recently
    # and need to be investigated
    # - name: Attempt to Load cargo-make From Cache
    #   id: cargo_make_cache
    #   uses: actions/cache@v4
    #   with:
    #     path: ${{ steps.get_cargo_tool_details.outputs.cargo_bin_path }}
    #     key: ${{ steps.get_cargo_tool_details.outputs.cargo_make_cache_key }}

    - name: Force cargo-make cache miss
      id: cargo_make_cache
      run: echo "cache-hit=false" >> $GITHUB_OUTPUT

    - name: Download cargo-make
      if: steps.cargo_make_cache.outputs.cache-hit != 'true'
      uses: robinraju/release-downloader@v1.11
      with:
        repository: 'sagiegurari/cargo-make'
        tag: '${{ steps.get_cargo_tool_details.outputs.cargo_make_version }}'
        fileName: 'cargo-make-v${{ steps.get_cargo_tool_details.outputs.cargo_make_version }}-x86_64-pc-windows-msvc.zip'
        out-file-path: 'cargo-make-download'
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Extract cargo-make
      if: steps.cargo_make_cache.outputs.cache-hit != 'true'
      env:
        CARGO_MAKE_VERSION: ${{ steps.get_cargo_tool_details.outputs.cargo_make_version }}
        DEST_DIR: ${{steps.get_cargo_tool_details.outputs.cargo_bin_path }}
      shell: python
      run: |
        import os
        import shutil
        import zipfile
        from pathlib import Path

        DOWNLOAD_DIR = Path(os.environ["GITHUB_WORKSPACE"], "cargo-make-download")
        ZIP_FILE_NAME = f"cargo-make-v{os.environ['CARGO_MAKE_VERSION']}-x86_64-pc-windows-msvc.zip"
        ZIP_FILE_PATH = Path(DOWNLOAD_DIR, ZIP_FILE_NAME)
        EXTRACT_DIR = Path(DOWNLOAD_DIR, "cargo-make-contents")

        with zipfile.ZipFile(ZIP_FILE_PATH, 'r') as zip_ref:
            zip_ref.extractall(EXTRACT_DIR)

        for extracted_file in EXTRACT_DIR.iterdir():
            if extracted_file.name == "cargo-make.exe":
                shutil.copy2(extracted_file, os.environ["DEST_DIR"])
                break

    - name: Rust Prep
      run: rustup component add rust-src

    - name: Get Platform Information
      id: get_platform_info
      env:
        BUILD_FILE_PATH: ${{ matrix.build_file }}
      shell: python
      run: |
        import importlib
        import inspect
        import os
        import sys
        from pathlib import Path
        from edk2toolext.invocables.edk2_platform_build import BuildSettingsManager
        from edk2toolext.invocables.edk2_ci_setup import CiSetupSettingsManager
        from edk2toolext.invocables.edk2_setup import SetupSettingsManager

        platform_build_file = Path(os.environ['BUILD_FILE_PATH'])
        if not platform_build_file.is_file():
            print(f"::error title=Invalid Build File!::Failed to find {str(platform_build_file)}!")
            sys.exit(1)

        # Load the module
        module_name = 'platform_settings'
        spec = importlib.util.spec_from_file_location(module_name, platform_build_file)
        module = importlib.util.module_from_spec(spec)
        spec.loader.exec_module(module)

        # Get info from the platform build file
        pkg_name = "UnknownPkg"
        ci_setup_supported = False
        setup_supported = False
        for name, obj in inspect.getmembers(module):
            if inspect.isclass(obj):
                if issubclass(obj, CiSetupSettingsManager):
                    ci_setup_supported = True
                if issubclass(obj, SetupSettingsManager):
                    setup_supported = True
                if issubclass(obj, BuildSettingsManager):
                    try:
                        pkg_name = obj().GetName()
                    except AttributeError:
                        print(f"::error title=Invalid Package name!::Failed to get package name in {str(platform_build_file)}!")
                        sys.exit(1)

        with open(os.environ['GITHUB_OUTPUT'], 'a') as fh:
            print(f'ci_setup_supported={str(ci_setup_supported).lower()}', file=fh)
            print(f'setup_supported={str(setup_supported).lower()}', file=fh)
            print(f'pkg_name={pkg_name}', file=fh)

    - name: Assign Temp Drive Letter
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
        subst Z: ${{ github.workspace }}

    - name: Setup
      if: steps.get_platform_info.outputs.setup_supported == 'true'
      shell: pwsh
      working-directory: "Z:"
      run: stuart_setup -c ${{ matrix.build_file }} -t DEBUG TOOL_CHAIN_TAG=${{ matrix.tool_chain_tag }}

    - name: Upload Setup Log As An Artifact
      uses: actions/upload-artifact@v4
      if: (success() || failure()) && steps.get_platform_info.outputs.setup_supported == 'true'
      with:
        name: ${{ steps.get_platform_info.outputs.pkg_name }}-Setup-Log
        path: |
          **/SETUPLOG.txt
          retention-days: 7
        if-no-files-found: ignore

    - name: CI Setup
      if: steps.get_platform_info.outputs.ci_setup_supported == 'true'
      shell: pwsh
      working-directory: "Z:"
      run: stuart_ci_setup -c ${{ matrix.build_file }} -t DEBUG TOOL_CHAIN_TAG=${{ matrix.tool_chain_tag }}

    - name: Upload CI Setup Log As An Artifact
      uses: actions/upload-artifact@v4
      if: (success() || failure()) && steps.get_platform_info.outputs.ci_setup_supported == 'true'
      with:
        name: ${{ steps.get_platform_info.outputs.pkg_name }}-CI-Setup-Log
        path: |
          **/CISETUP.txt
          retention-days: 7
        if-no-files-found: ignore

    - name: Update
      shell: pwsh
      working-directory: "Z:"
      run: stuart_update -c ${{ matrix.build_file }} -t DEBUG TOOL_CHAIN_TAG=${{ matrix.tool_chain_tag }}

    - name: Upload Update Log As An Artifact
      uses: actions/upload-artifact@v4
      if: success() || failure()
      with:
        name: ${{ steps.get_platform_info.outputs.pkg_name }}-Update-Log
        path: |
          **/UPDATE_LOG.txt
        retention-days: 7
        if-no-files-found: ignore

    - name: Platform Build
      shell: pwsh
      working-directory: "Z:"
      env:
        RUST_ENV_CHECK_TOOL_EXCLUSIONS: "cargo fmt, cargo tarpaulin"
      run: stuart_build -c ${{ matrix.build_file }} TARGET=DEBUG TOOL_CHAIN_TAG=${{ matrix.tool_chain_tag }} SHUTDOWN_AFTER_RUN=TRUE QEMU_HEADLESS=TRUE EMPTY_DRIVE=TRUE BLD_*_QEMU_CORE_NUM=2 --FlashRom

    - name: Build Cleanup
      id: build_cleanup
      shell: python
      run: |
        import os
        import shutil
        from pathlib import Path

        dirs_to_delete = ['ia32', 'x64', 'arm', 'aarch64']

        def delete_dirs(path: Path):
            if path.exists() and path.is_dir():
                if path.name.lower() in dirs_to_delete:
                    print(f'Removed {str(path)}')
                    shutil.rmtree(path)
                    return

                for child_dir in path.iterdir():
                    delete_dirs(child_dir)

        build_path = Path(os.environ['GITHUB_WORKSPACE'], 'Build')
        delete_dirs(build_path)

    - name: Upload Build Logs As An Artifact
      uses: actions/upload-artifact@v4
      if: success() || failure()
      with:
        name: ${{ steps.get_platform_info.outputs.pkg_name }}-Build-Logs
        path: |
          **/BUILD_REPORT.TXT
          **/OVERRIDELOG.TXT
          **/BUILDLOG_*.md
          **/BUILDLOG_*.txt
          **/CI_*.md
          **/CI_*.txt
        retention-days: 7
        if-no-files-found: ignore

    - name: Remove Temp Drive Letter
      if: runner.os == 'Windows'
      shell: pwsh
      run: |
          subst Z: /D
