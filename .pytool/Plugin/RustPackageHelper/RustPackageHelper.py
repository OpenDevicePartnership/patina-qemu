
# @file RustPackageHelper.py
# HelperFucntion used to share the RustPackage
# class to the rest of the build system.
##
# Copyright (c) Microsoft Corporation.
# SPDX-License-Identifier: BSD-2-Clause-Patent
##
from edk2toolext.environment.plugintypes.uefi_helper_plugin import IUefiHelperPlugin
from edk2toollib.utility_functions import RunCmd

from pathlib import Path
import io
import os
import time
import toml
from typing import Union

class RustPackage:
    def __init__(self, path: Path):
        self.path = path
        self.name = path.name
    
    def __str__(self):
        return f'{self.name}@{self.path}'
    
    def __repr__(self) -> str:
        return self.__str__()
    
    def __eq__(self, other: 'RustPackage') -> bool:
        return self.name == other.name and self.path == other.path

    def __ne__(self, other: 'RustPackage') -> bool:
        return not self.__eq__(other)
    
    def __hash__(self) -> int:
        return hash((self.name, self.path))

    def clean(self):
        """Cleans any build artifacts from the directory.
        
        Ensures tests are freshly built and executed.
        """
        command = "cargo"
        parameters = "clean"

        RunCmd(command, parameters, workingdir=self.path)
        time.sleep(1) # Cargo clean returns immediately, wait for it to finish
    
    def test(self, ws):
        """Runs any tests located within the library.
        
        Returns:
            (dict): dict containing all test results
        """
        command = "cargo"
        params = f"make -e TEST_FLAGS=\"-- -Z unstable-options --format json\" test {self.name}"
        output = io.StringIO()

        if RunCmd(command, params, workingdir=ws, outstream=output) != 0:
            output.seek(0)
            raise RuntimeError(output.read())
        output.seek(0)
        return self.__clean_output(output)
    
    def coverage(self, ws):
        """Performs code coverage on the package and returns the results.
        
        Returns:
            (dict): dict containing all coverage results
        """
        command = "cargo"
        params = f"make cov {self.name}"
        output = io.StringIO()

        if RunCmd(command, params, workingdir=ws, outstream=output) != 0:
            output.seek(0)
            raise RuntimeError(output.read())
        output.seek(0)
        return self.__clean_cov_output(output)
       
    def __clean_output(self, output: io.StringIO):
        """Searches the output only for json lines to return."""
        out = []
        for line in output.readlines():
            line = line.strip()
            if line.startswith('{') and line.endswith('}'):
                entry = eval(line)  # Transform line into dict
                out.append(entry)

        return out

    def __clean_cov_output(self, output: io.StringIO):
        """Cleans the output to only return the coverage results in a dict format."""
        out = []
        for line in output.readlines():
            
            # Skip any lines not generated by the coverage tool
            if not line.startswith("||"):
                continue
            
            # Remove the leading pipes
            line = line.strip("| ")

            # Skip any lines that we don't care about
            if line.startswith("Tested/Total Lines:") or line.strip() == "":
                continue
            
            path, cov = tuple(line.split(":")[0:2])
            covered, total = tuple(cov.replace("/", " ").split()[0:2])

            out.append({"package": self.name, "path": path.strip("||"), "covered": int(covered), "total": int(total)})

        return out

class RustWorkspace:
    def __init__(self, path: Union[Path, str]):
        self.path: Path = Path(path)
        self.toml: dict = {}
        self.members: list[RustPackage] = []

        self.__load_toml()
        self.__set_members()
    
    def __load_toml(self):
        """Finds all members of the workspace."""
        try:
            self.toml = toml.load(self.path / "Cargo.toml")
        except:
            raise Exception(f"Failed to load Cargo.toml from {self.path}")
        
    def __set_members(self):
        workspace = self.toml.get("workspace")
        members = set()

        # Grab all members specifically specified in the workspace
        for member in workspace["members"]:
            members.add(RustPackage(self.path / member))

        # Build a dep list that only contains dependencies with a path. These are workspace
        # members.
        dep_list = workspace["dependencies"]
        dep_list = [dep_list[dep] for dep in dep_list if type(dep_list[dep]) != str and dep_list[dep].get("path")]
        
        for dep in dep_list:
            members.add(RustPackage(self.path / dep["path"]))
        
        self.members = list(members)

    def coverage(self, report_type: str = None ):
        """Runs coverage at the workspace level.
        
        Generates a single report that provides coverage information for all
        packages in the workspace.
        """ 
        command = "cargo"
        params = " make"
        if report_type:
            params += f' -e COV_FLAGS="--out {report_type}"'
        params += f" cov"
        if RunCmd(command, params, workingdir=self.path) != 0:
            raise RuntimeError("Failed to generate coverage report")


class RustPackageHelper(IUefiHelperPlugin):
    def RegisterHelpers(self, obj):
        fp = os.path.abspath(__file__)
        obj.Register("RustPackage", RustPackage, fp)
        obj.Register("RustWorkspace", RustWorkspace, fp)